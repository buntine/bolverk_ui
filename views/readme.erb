<h3>README</h3>
<ol>
  <li>
    <h4>Requirements / Notes</h4>
    <p>At this point in time, both Javascript and Cookies must be enabled for this interface to work as intended. Sorry!</p>
    <p>If you want to check out the engine behind this implementation, check it out here: <a href="http://www.github.com/buntine/bolverk">http://www.github.com/buntine/bolverk</a>.</p>
    <p>I have also written an <a href="http://andrewbuntine.com/articles/2009/4/2/programming-bolverk-a-simple-example">introductory blog post</a>, which explains a simple use-case.
  </li>
  <li>
    <h4>Definition</h4>
    <p>Bolverk is an emulator for a typical machine language. I have developed it in an attempt to
    better understand the way machines work at a low-level and potentially as an educational tool
    for students who prefer to see a machine language in action in a virtual environment.</p>
    <p>With Bolverk, you can write a machine language program, and then step through the operation one
    "machine cycle" at time. At each point, you can dissect main memory and all registers. This is a
    great way to see how the program effects memory in realtime.</p>
    <p>Programs are written in base-16 (hexadecimal). The language design is based on the one described
    in J. Glenn Brookshears textbook -- Computer Science: An Overview (3rd edition, 1991).</p>
  </li>
  <li>
    <h4>Architecture</h4>
    <ul class="spec">
      <li>The machine has 16 registers identified in hexadecimal as 0 through to F.</li>
      <li>Each register can hold one byte (8 bits).</li>
      <li>Main memory consists of 256 cells.</li>
      <li>Each memory cell can hold one byte.</li>
      <li>Memory cells can be referenced in hexadecimal as 00 (00000000) to FF (11111111).</li>
    </ul>
  </li>
  <li>
    <h4>Machine Language</h4>
    <ul class="spec">
      <li>Machine instructions are 16 bits (two bytes) in length, therefore each instruction requires two memory cells.</li>
      <li>The first 4 bits make up the op-code. The following 12 bits make up the operand field.</li>
      <li>See the LANGUAGE_SPEC document for a listing of the available instructions.</li>
    </ul>
  </li>
  <li>
    <h4>Storing Integers and Fractions</h4>
    <p>To represent signed integers, binary numbers are encoded in Two's Complement Notation.
    Therefore, the range of numbers than can be stored is -128 to 127. This should be sufficient
    for educational purposes.</p>
    <p>Fractions are stored in Floating Point Notation using the following layout: 0 000 0000</p>
    <p>
    1)    Sign bit.<br />
    2..4) Exponent field, encoded in Excess Four Notation<br />
    5..8) Mantissa field<br />
    </p>
    <p>It's worth noting that my Floating Point implemenation is very limited as only one byte is
    reserved per number (most systems would use atleast 32 bits). Therefore, round-off errors
    and overflows are going to be rather common unless you are dealing with a very small range
    of numbers (roughly 1/256 to 7 1/2).</p>
  </li>
</ol>
